---
title: 'Vignette for eigTest'
author: "Yuchen Xu"
date: "11/10/2020"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette for eigTest}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Package installation

To install and load the package, use the code:
```{r install, message=FALSE, warning=FALSE}
fail = TRUE
try( {library(eigTest); fail = FALSE}, TRUE )
if (fail) {
  devtools::install_github('XycYuchenXu/eigTest', quiet = T, build_vignettes = F)
  library(eigTest)
}
```

## Simulation samples

The sample generating process is as follows:

1. Randomly sample a common eigenvector matrix $V(k; d) \in \mathbb{R}^{d \times k}$, where $d$ is the matrix dimension, $k \in \{1, \dots, d\}$ is the number of common components, and the entries are i.i.d. standard normal;

2. Set $V_i(k; d) = V(k; d)$ if $k = d$, otherwise span $V_i(k; d) = (V(k; d), \widetilde{V}_i) \in \R^{d \times d}$ with random but sufficiently distinct $\widetilde{V}_i \in \R^{d \times (d-k)}$ for $i = 1, \dots, p$.

3. For $i=1, \dots, p$:
  1. Perturb the $i$-th eigenvector matrix $V_i(k; d)$ as $V_i(\rho, k; d) = V_i(k; d) + \rho E_i$ with noise $E_i$ to be independent and standard normal, element-wise.
  2. Randomly generate non-singular diagonal matrices $D_i \in \R^{d \times d}$ for $i = 1, \dots, p$.

4. Generate the target matrices $\mathcal{M}_p(\rho, k; d) = \{\mu_i(\rho, k; d)\} = \{ V_i(\rho, k; d) D_i V_i^{-1}(\rho, k; d)\}_{i=1}^p$.

5. Given sample size $n$, generate $n$ random matrices $X_{ij}(\rho, k; d), j = 1, \dots, n$ with mean $\mu_i(\rho, k; d)$ and identity variance matrix, and get the estimates $A_i(\rho, k; d) = \bar X_{ij}(\rho, k; d)$, $\Sigma_i(\rho, k; d) = \frac{1}{n-1} \sum_{j=1}^n \mbox{vec}(X_{ij}(\rho, k; d) - A_i(\rho, k; d)) \mbox{vec}'(X_{ij}(\rho, k; d) - A_i(\rho, k; d))$.

The package includes functions to generate simulation samples in the following way:

```{r simuSamples, echo=TRUE, message=FALSE, warning=FALSE}
full_means = generateMeans(d = 5,           # square matrix's dimension
                           p = 4,           # number of matrices
                           snr = c(10,1))   # vector of SNR in eigenvector

full_samples = simuSamples(mu = full_means,                # mean matrices
                           cn = c(sqrt(100), sqrt(500)),   # convergence rate
                           reps = 200)                     # replicate

eg_full_mat = full_samples[[1]][[1]]; print(dim(eg_full_mat))
eg_full_cov = full_samples[[1]][[2]]; print(dim(eg_full_cov))

part_means = generateMeans(d = 5,           # square matrix's dimension
                           p = 4,           # number of matrices
                           k = 3,           # number of components
                           snr = c(10,1),   # vector of SNR in eigenvector
                           nonneg = FALSE)  # nonnegativity

part_samples = simuSamples(mu = part_means,                # mean matrices
                           cn = c(sqrt(100), sqrt(500)),   # convergence rate
                           reps = 200,                     # replicate
                           nonneg = FALSE)                 # nonnegativity

eg_part_mat = part_samples[[1]][[1]]; print(dim(eg_part_mat))
eg_part_cov = part_samples[[1]][[2]]; print(dim(eg_part_cov))
```


## Functionality

### Two-sample test

```{r twoSample, echo=TRUE, message=FALSE, warning=FALSE}
## Commutator-based test
commutatorTest(mat.arr = eg_full_mat[1,1,,,],  # sample matrices
               cn = sqrt(100),                 # convergence rate
               cov.arr = eg_full_cov[1,1,,,],  # covariance matrices
               param.out = TRUE)               # return parameters

## Log-likelihood ratio test
projTest(A = eg_part_mat[1,1,,,],        # sample matrices
         cn = sqrt(100),                 # convergence rate
         cov.arr = eg_part_cov[1,1,,,],  # covariance matrices
         param.out = TRUE)               # return parameters
```

### Common eigenvector estimate

```{r eigEst, eval=FALSE, include=FALSE}
JDTE()
```

### Multi-sample test

```{r multiSample, eval=FALSE, include=FALSE}
eigTest()
```

### Partial test

```{r partial, eval=FALSE, include=FALSE}

```

