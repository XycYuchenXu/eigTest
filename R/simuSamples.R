#' Generating consistent estimators for given means
#'
#' The consistent estimators are obtained either as the mean of standard normally distributed matrices,
#' or as the estimated transition probability matrix of simulated Markov processes.
#' In addition the estimated covariance matrices are also returned.
#'
#' @param reps The number of replicates for the same distribution.
#' @param cn The vector of convergence rates in each replicate. Assume \code{n} is the sample size, usually CLT indicates \code{cn = sqrt(n)} for consistent estimators.
#' @param mu The array of mean matrices, possibly generated by function \code{generateMeans}. Dimension should be \code{p}-by-\code{q}-by-\code{d}-by-\code{d}, where \code{p} is the number of matrices, \code{q} is the number of SNR's to be used, and \code{d} is the dimension of square matrices.
#' @param nonneg Logical, whether the generated matrices should be nonnegative as transition probability matrices. Default to \code{nonneg = FALSE}
#' @param est.cov Logical, whether the covariance matrices are estimated empirically. Default to \code{est.cov = TRUE}.
#' @param prl Logical, whether to use parallel sampling. Default to \code{prl = FALSE} for not parallelizing. If \code{prl == TRUE}, one must first call \code{registerDoSNOW()} externally.
#'
#' @return A list of lists, with length \code{reps * m * q}, where \code{m} is the number of different rates \code{m = length(cn)}. Every sublist has the following format.
#' \itemize{
#' \item \code{SNR}: The string indicating signal to noise ratio.
#' \item \code{CovRate}: The numerical value indicating the corresponding convergence rate in \code{cn}.
#' \item \code{mu.bar}: The array of consistent estimators of the mean matrices, with dimension \code{p}-\code{d}-by-\code{d}.
#' \item \code{cov.bar}: The array of consistent estimators of covariance matrices, with dimension \code{p}-\code{d^2}-by-\code{d^2}.
#' }
#' When \code{est.cov = FALSE}, only the first array of mean estimators are included in the sublist.
#'
#' @import utils
#' @import foreach
#' @import doSNOW
#' @import abind
#' @export
#'
#' @examples simuSamples(generateMeans(5,4,3), sqrt(c(50,100)), 50)
simuSamples = function(mu, cn, reps, nonneg = FALSE,
                       est.cov = TRUE, prl = FALSE){

  p = dim(mu)[1]; matIDs = dimnames(mu)[[1]]
  out.groups = dim(mu)[2]; snrs = dimnames(mu)[[2]]
  d = dim(mu)[3]
  num.size = length(cn)

  if (nonneg) {
    estMat = function(Mat, cm, s, i){
      n = round(cm^2)
      n = nrow(Mat)
      Label = matrix(0, nrow = n+1, ncol = 1)
      CountMat = matrix(0, nrow = n, ncol = n)
      Label[1] = sample(n,1)
      for (l in 2:(n+1)) {
        Label[l] = sample(n,1,prob = Mat[Label[l-1],],replace = TRUE)
        CountMat[Label[l-1], Label[l]] = CountMat[Label[l-1], Label[l]]+1
      }
      for (j in 1:n) {
        sums = 1/sum(CountMat[j,])
        if (is.infinite(sums)) {sums = 0}
        CountMat[j,] = CountMat[j,]*sums[1]
      }

      if (est.cov) {
        CovMat = matrix(0, ncol = n^2, nrow = n^2)
        pi = matrix(0, nrow = n, ncol = 1)
        for (j in 1:n) {
          pi[j] = sum(Label == j)/(n+1)
        }
        vec = 1/pi
        vec[is.infinite(vec)] = 0
        Ei = matrix(0, ncol = n, nrow = n)
        for (j in 1:n) {
          Ei[j,j] = 1
          Qi = diag(CountMat[j,]) - matrix(CountMat[j,], nrow = n, ncol = n) * matrix(CountMat[j,], nrow = n, ncol = n, byrow = T)
          CovMat = CovMat + kronecker(Qi * vec[j], Ei)
          Ei[j,j] = 0
        }
        dim(CovMat) = c(1, dim(CovMat))
      }
      dim(CountMat) = c(1, dim(CountMat))
      nameList = list(matIDs[i], NULL, NULL)
      dimnames(CountMat) = nameList
      if (est.cov) {
        dimnames(CovMat) = nameList
        return(list(SNR = snrs[s], CovRate = cm, mu.bar = CountMat, cov.bar = CovMat))
      }
      return(list(SNR = snrs[s], CovRate = cm, mu.bar = CountMat))
    }
  } else {
    estMat = function(Mat, cm, s, i){
      n = round(cm^2)
      d = nrow(Mat)
      erMat = matrix(0, n, d^2)
      for (j in 1:n) {
        erMat[j,] = rnorm(d^2)
      }
      estMat = Mat + matrix(colMeans(erMat), nrow = d)
      if (est.cov) {CovMat = cov(erMat); dim(CovMat) = c(1, dim(CovMat))}
      dim(estMat) = c(1, dim(estMat))
      nameList = list(matIDs[i], NULL, NULL)
      dimnames(estMat) = nameList
      if (est.cov) {
        dimnames(CovMat) = nameList
        return(list(SNR = snrs[s], CovRate = cm, mu.bar = estMat, cov.bar = CovMat))
      }
      return(list(SNR = snrs[s], CovRate = cm, mu.bar = estMat))
    }
  }

  acomb = function(...){
    argl = list(...)
    out = argl[[1]]
    if (length(argl) >= 2) {
      for (i in 2:length(argl)) {
        out$mu.bar = abind(out$mu.bar, argl[[i]]$mu.bar, along = 1)
        if (length(out) == 4) {out$cov.bar = abind(out$cov.bar, argl[[i]]$cov.bar, along = 1)}
      }
    }
    return(out)
  }

  cm = NULL; i = NULL; s = NULL; j = NULL
  if (prl) {
    cat('Sampling: \n')
    pb <- txtProgressBar(max = num.size*out.groups*reps*p, style = 3)
    progress <- function(n) {setTxtProgressBar(pb, n)}
    opts <- list(progress = progress)

    output = foreach(j=1:reps, .options.snow = opts, .combine = c,
                     .multicombine = T) %:%
      foreach(cm = cn, .combine = c) %:%
      foreach(s = 1:out.groups, .combine = c) %:%
      foreach(i = 1:p, .combine = acomb) %dopar% {
        if (j %% max(5, reps %/% 10) == 1 && s == 1 && i == 1 && cm == cn[1]) {gc(); gc()}
        return(estMat(mu[i,s,,], cm, s, i))
      }
  } else {
    output = foreach(j=1:reps, .combine = c, .multicombine = T) %:%
      foreach(cm = cn, .combine = c) %:%
      foreach(s = 1:out.groups, .combine = c) %:%
      foreach(i = 1:p, .combine = acomb) %do% {
        if (j %% max(5, reps %/% 10) == 1 && s == 1 && i == 1 && cm == cn[1]) {gc(); gc()}
        return(estMat(mu[i,s,,], cm, s, i))
      }
  }
  gc(); gc()
  return(output)
}
