#' Generating consistent estimators for given means
#'
#' The consistent estimators are obtained either as the mean of standard normally distributed matrices,
#' or as the estimated transition probability matrix of simulated Markov processes.
#' In addition the estimated covariance matrices are also returned.
#'
#' @param reps Number of replicates for the same distribution
#' @param cn Vector of convergence rattes in each replicate, set \code{n} as the sample size,
#'           usually CLT indicates consistent estimators requires \code{n = cn^2}.
#' @param mu Array of mean matrices, possibly generated by function \code{generateMeans},
#'           dimension should be \code{p}-by-\code{q}-by-\code{d}-by-\code{d}, where \code{p} is the number of matrices,
#'           \code{q} is the number of SNR's to be used, and \code{d} is the dimension of square matrices.
#' @param nonneg Whether the samples should be all nonnegative.
#'
#' @return List of arrays.
#' \itemize{
#' \item mu.bar The array of consistent estimators of the mean matrices,
#' \item cov.bar The array of consistent estimators of covariance matrices.
#' }
#'
#' @export
#'
#' @examples simuSamples(generateMeans(5,4,3), sqrt(c(50,100)), 50)
simuSamples = function(mu, cn, reps, nonneg = FALSE){

  p = dim(mu)[1]
  d = dim(mu)[3]
  out.groups = dim(mu)[2]
  num.size = length(cn)

  if (nonneg) {
    markovProcess = function(P,L){
      L = floor(L)
      n = nrow(P)
      Label = matrix(0, nrow = L+1, ncol = 1)
      CountMat = matrix(0, nrow = n, ncol = n)
      Label[1] = sample(n,1)
      for (l in 2:(L+1)) {
        Label[l] = sample(n,1,prob = P[Label[l-1],],replace = TRUE)
        CountMat[Label[l-1], Label[l]] = CountMat[Label[l-1], Label[l]]+1
      }
      for (i in 1:n) {
        sums = 1/sum(CountMat[i,])
        if (is.infinite(sums)) {sums = 0}
        CountMat[i,] = CountMat[i,]*sums[1]
      }

      CovMat = matrix(0, ncol = n^2, nrow = n^2)
      pi = matrix(0, nrow = n, ncol = 1)
      for (i in 1:n) {
        pi[i] = sum(Label == i)/(L+1)
      }
      vec = 1/pi
      vec[is.infinite(vec)] = 0
      for (i in 1:n) {
        Ei = matrix(0, ncol = n, nrow = n)
        Ei[i,i] = 1
        Qi = diag(CountMat[i,]) - matrix(CountMat[i,], nrow = n, ncol = n) * matrix(CountMat[i,], nrow = n, ncol = n, byrow = T)
        CovMat = CovMat + kronecker(Qi * vec[i], Ei)
      }
      return(list(CountMat, CovMat))
    }

  } else {
    estMat = function(Mat, n){
      n = floor(n)
      d = nrow(Mat)
      erMat = matrix(0, n, d^2)
      for (i in 1:n) {
        erMat[i,] = rnorm(d^2)
      }
      estMat = Mat + matrix(colMeans(erMat), nrow = d)
      estCov = cov(erMat)
      return(list(estMat, estCov))
    }
  }

  out.samples = array(0, dim = c(num.size, out.groups, reps, p, d, d))
  out.cov = array(0, dim = c(num.size, out.groups, reps, p, d^2, d^2))

  dimnames(out.samples) = list(
    paste0('Sample size n=', round(cn^2)),
    dimnames(mu)[[2]],
    paste0('Replica #', 1:reps),
    dimnames(mu)[[1]],
    NULL, NULL
  )
  dimnames(out.cov) = list(
    paste0('Sample size n=', round(cn^2)),
    dimnames(mu)[[2]],
    paste0('Replica #', 1:reps),
    dimnames(mu)[[1]],
    NULL, NULL
  )

  for (s in 1:num.size) {
    cm = cn[s]
    for (l in 1:out.groups) {
      for (j in 1:reps) {
        for (i in 1:p) {
          if (nonneg) {
            TPM = markovProcess(mu[i,l,,], cm^2)
            out.samples[s,l,j,i,,] = TPM[[1]]
            out.cov[s,l,j,i,,] = TPM[[2]]
          } else {
            estM = estMat(mu[i,l,,], cm^2)
            out.samples[s,l,j,i,,] = estM[[1]]
            out.cov[s,l,j,i,,] = estM[[2]]
          }
        }
      }
    }
  }

  return(list(mu.bar = out.samples, cov.bar = out.cov))
}
