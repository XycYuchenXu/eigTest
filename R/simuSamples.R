#' Generating consistent estimators for given means
#'
#' The consistent estimators are obtained either as the mean of standard normally distributed matrices,
#' or as the estimated transition probability matrix of simulated Markov processes.
#' In addition the estimated covariance matrices are also returned.
#'
#' @param samples Number of replicates for the same distribution
#' @param cn Vector of constants for convergence in each replicate, usually \code{sqrt(n)} in CLT,
#'          i.e. the sample size to get the consistent estimators is \code{n = M^2}.
#' @param mu Array of mean matrices, possibly generated by function \code{generateMeans},
#'           dimension should be \code{p}-by-\code{q}-by-\code{d}-by-\code{d}, where \code{p} is the number of matrices,
#'           \code{q} is the number of SNR's to be used, and \code{d} is the dimension of square matrices.
#' @param nonneg Whether the samples should be all nonnegative.
#'
#' @return List of lists.
#' \itemize{
#' \item mu.bar The list of consistent estimators of the mean matrices,
#' \item cov.bar The list of consistent estimators of covariance matrices.
#' }
#'
#'
#' @export
#'
#' @import 'MASS'
#'
#' @examples simuSamples(generateMeans(5,4,3), sqrt(c(50,100)), 50)
simuSamples = function(mu, cn, samples, nonneg = FALSE){

  p = dim(mu)[1]
  d = dim(mu)[3]
  out.groups = dim(mu)[2]
  num.size = length(cn)

  if (nonneg) {
    markovProcess = function(P,L){
      L = floor(L)
      n = nrow(P)
      Label = matrix(0, nrow = L+1, ncol = 1)
      CountMat = matrix(0, nrow = n, ncol = n)
      Label[1] = sample(n,1)
      for (l in 2:(L+1)) {
        Label[l] = sample(n,1,prob = P[Label[l-1],],replace = TRUE)
        CountMat[Label[l-1], Label[l]] = CountMat[Label[l-1], Label[l]]+1
      }
      for (i in 1:n) {
        sums = 1/sum(CountMat[i,])
        if (is.infinite(sums)) {sums = 0}
        CountMat[i,] = CountMat[i,]*sums[1]
      }

      CovMat = matrix(0, ncol = n^2, nrow = n^2)
      pi = matrix(0, nrow = n, ncol = 1)
      for (i in 1:n) {
        pi[i] = sum(Label == i)/(L+1)
      }
      vec = 1/pi
      vec[is.infinite(vec)] = 0
      for (i in 1:n) {
        Ei = matrix(0, ncol = n, nrow = n)
        Ei[i,i] = 1
        Qi = diag(CountMat[i,]) - matrix(CountMat[i,], nrow = n, ncol = n) * matrix(CountMat[i,], nrow = n, ncol = n, byrow = T)
        CovMat = CovMat + kronecker(Qi * vec[i], Ei)
      }
      return(list(CountMat, CovMat))
    }

  } else {
    estMat = function(Mat, n){
      n = floor(n)
      d = nrow(Mat)
      erMat = matrix(0, n, d^2)
      for (i in 1:n) {
        erMat[i,] = rnorm(d^2)
      }
      estMat = Mat + matrix(colMeans(erMat), nrow = d)
      estCov = cov(erMat)
      return(list(estMat, estCov))
    }
  }

  out.cov = vector('list', num.size)
  all.cov = vector('list', out.groups)
  A.cov = vector('list', p)
  A.snr.cov = vector('list', samples)

  out.samples = vector('list', num.size)
  all.samples = vector('list', out.groups)
  A = vector('list', p)
  A.snr = vector('list', samples)

  for (s in 1:num.size) {
    cm = cn[s]
    for (l in 1:out.groups) {
      for (j in 1:samples) {
        for (i in 1:p) {
          if (nonneg) {
            TPM = markovProcess(mu[i,l,,], cm^2)
            A[[i]] = TPM[[1]]
            A.cov[[i]] = TPM[[2]]
          } else {
            estM = estMat(mu[i,l,,], cm^2)
            A[[i]] = estM[[1]]
            A.cov[[i]] = estM[[2]]
          }
        }
        A.snr[[j]] = A
        A.snr.cov[[j]] = A.cov
      }
      all.samples[[l]] = A.snr
      all.cov[[l]] = A.snr.cov
    }
    out.samples[[s]] = all.samples
    out.cov[[s]] = all.cov
  }

  return(list(mu.bar = out.samples, cov.bar = out.cov))
}
