#' Generating consistent estimators for given means
#'
#' The consistent estimators are obtained either as the mean of standard normally distributed matrices,
#' or as the estimated transition probability matrix of simulated Markov processes.
#' In addition the estimated covariance matrices are also returned.
#'
#' @param reps The number of replicates for the same distribution.
#' @param cn The vector of convergence rates in each replicate. Assume \code{n} is the sample size, usually CLT indicates \code{cn = sqrt(n)} for consistent estimators.
#' @param mu The array of mean matrices, possibly generated by function \code{generateMeans}. Dimension should be \code{p}-by-\code{q}-by-\code{d}-by-\code{d}, where \code{p} is the number of matrices, \code{q} is the number of SNR's to be used, and \code{d} is the dimension of square matrices.
#' @param nonneg Logical, whether the generated matrices should be nonnegative as transition probability matrices. Default to \code{nonneg = FALSE}
#' @param est.cov Logical, whether the covariance matrices are estimated empirically. Default to \code{est.cov = TRUE}.
#' @param prl Logical, whether to use parallel sampling. Default to \code{prl = FALSE} for not parallelizing. If \code{prl == TRUE}, one must first call \code{registerDoSNOW()} externally.
#'
#' @return A list of lists, with length \code{reps}. Every sublist has the following format.
#' \itemize{
#' \item \code{mu.bar}: The array of consistent estimators of the mean matrices, with dimension \code{m}-by-\code{q}-by-\code{p}-\code{d}-by-\code{d}, where \code{m} is the number of different rates \code{m = length(cn)}.
#' \item \code{cov.bar}: The array of consistent estimators of covariance matrices, with dimension \code{m}-by-\code{q}-by-\code{p}-\code{d^2}-by-\code{d^2}, where \code{m} is the number of different rates \code{m = length(cn)}.
#' }
#' When \code{est.cov = FALSE}, only the first array of mean estimators are included in the sublist.
#'
#' @import utils
#' @import foreach
#' @import doSNOW
#' @export
#'
#' @examples simuSamples(generateMeans(5,4,3), sqrt(c(50,100)), 50)
simuSamples = function(mu, cn, reps, nonneg = FALSE,
                       est.cov = TRUE, prl = FALSE){

  p = dim(mu)[1]; matIDs = dimnames(mu)[[1]]
  out.groups = dim(mu)[2]; snrs = dimnames(mu)[[2]]
  d = dim(mu)[3]
  num.size = length(cn)

  if (nonneg) {
    markovProcess = function(P, L, s, i){
      L = round(L)
      n = nrow(P)
      Label = matrix(0, nrow = L+1, ncol = 1)
      CountMat = matrix(0, nrow = n, ncol = n)
      Label[1] = sample(n,1)
      for (l in 2:(L+1)) {
        Label[l] = sample(n,1,prob = P[Label[l-1],],replace = TRUE)
        CountMat[Label[l-1], Label[l]] = CountMat[Label[l-1], Label[l]]+1
      }
      for (j in 1:n) {
        sums = 1/sum(CountMat[j,])
        if (is.infinite(sums)) {sums = 0}
        CountMat[j,] = CountMat[j,]*sums[1]
      }

      if (est.cov) {
        CovMat = matrix(0, ncol = n^2, nrow = n^2)
        pi = matrix(0, nrow = n, ncol = 1)
        for (j in 1:n) {
          pi[j] = sum(Label == j)/(L+1)
        }
        vec = 1/pi
        vec[is.infinite(vec)] = 0
        for (j in 1:n) {
          Ei = matrix(0, ncol = n, nrow = n)
          Ei[j,j] = 1
          Qi = diag(CountMat[j,]) - matrix(CountMat[j,], nrow = n, ncol = n) * matrix(CountMat[j,], nrow = n, ncol = n, byrow = T)
          CovMat = CovMat + kronecker(Qi * vec[j], Ei)
        }
        dim(CovMat) = c(rep(1, 3), dim(CovMat))
      }
      dim(CountMat) = c(rep(1, 3), dim(CountMat))
      nameList = list(paste0('Sample size n=', L), snrs[s], matIDs[i], NULL, NULL)
      dimnames(CountMat) = nameList
      if (est.cov) {
        dimnames(CovMat) = nameList
        return(list(mu.bar = CountMat, cov.bar = CovMat))
      }
      return(list(mu.bar = CountMat))
    }
  } else {
    estMat = function(Mat, n, s, i){
      n = floor(n)
      d = nrow(Mat)
      erMat = matrix(0, n, d^2)
      for (j in 1:n) {
        erMat[j,] = rnorm(d^2)
      }
      estMat = Mat + matrix(colMeans(erMat), nrow = d)
      if (est.cov) {CovMat = cov(erMat); dim(CovMat) = c(rep(1, 3), dim(CovMat))}
      dim(estMat) = c(rep(1, 3), dim(estMat))
      nameList = list(paste0('Sample size n=', n), snrs[s], matIDs[i], NULL, NULL)
      dimnames(estMat) = nameList
      if (est.cov) {
        dimnames(CovMat) = nameList
        return(list(mu.bar = estMat, cov.bar = CovMat))
      }
      return(list(mu.bar = estMat))
    }
  }

  acomb1 = function(...) acomb(..., along = 1)
  acomb2 = function(...) acomb(..., along = 2)
  acomb3 = function(...) acomb(..., along = 3)

  cm = NULL; i = NULL; s = NULL
  if (prl) {
    cat('Sampling: \n')
    pb <- txtProgressBar(max = num.size*out.groups*reps*p, style = 3)
    progress <- function(n) {setTxtProgressBar(pb, n)}
    opts <- list(progress = progress)

    output = foreach(j=1:reps, .options.snow = opts) %:%
      foreach(cm = cn, .combine = acomb1) %:%
      foreach(s=1:out.groups, .combine = acomb2) %:%
      foreach(i=1:p, .combine = acomb3) %dopar% {
        if (nonneg) { out = markovProcess(mu[i,s,,], cm^2, s, i) }
        else { out = estMat(mu[i,s,,], cm^2, s, i) }
        gc()
        out
      }
  } else {
    output = foreach(j=1:reps) %:%
      foreach(cm = cn, .combine = acomb1) %:%
      foreach(s=1:out.groups, .combine = acomb2) %:%
      foreach(i=1:p, .combine = acomb3) %do% {
        if (nonneg) { out = markovProcess(mu[i,s,,], cm^2, s, i) }
        else { out = estMat(mu[i,s,,], cm^2, s, i) }
        gc()
        out
      }
  }
  return(output)
}
