#' Generating consistent estimators for given means
#'
#' The consistent estimators are obtained either as the mean of standard normally distributed matrices,
#' or as the estimated transition probability matrix of simulated Markov processes.
#' In addition the estimated covariance matrices are also returned.
#'
#' @param reps The number of replicates for the same distribution.
#' @param cn The vector of convergence rates in each replicate. Assume \code{n} is the sample size, usually CLT indicates \code{cn = sqrt(n)} for consistent estimators.
#' @param mu The array of mean matrices, possibly generated by function \code{generateMeans}. Dimension should be \code{p}-by-\code{q}-by-\code{d}-by-\code{d}, where \code{p} is the number of matrices, \code{q} is the number of SNR's to be used, and \code{d} is the dimension of square matrices.
#' @param nonneg Logical, whether the generated matrices should be nonnegative as transition probability matrices. Default to \code{nonneg = FALSE}
#' @param est.cov Logical, whether the covariance matrices are estimated empirically. Default to \code{est.cov = TRUE}.
#' @param prl Logical, whether to use parallel sampling. Default to \code{prl = FALSE} for not parallelizing. If \code{prl == TRUE}, one must first call \code{registerDoSNOW()} externally.
#'
#' @return A list of arrays. When \code{est.cov = FALSE}, only the first array of mean estimators are included in the output list.
#' \itemize{
#' \item \code{mu.bar}: The array of consistent estimators of the mean matrices, with dimension \code{m}-by-\code{q}-by-\code{p}-\code{d}-by-\code{d}, where \code{m} is the number of different rates \code{m = length(cn)}.
#' \item \code{cov.bar}: The array of consistent estimators of covariance matrices, with dimension \code{m}-by-\code{q}-by-\code{p}-\code{d^2}-by-\code{d^2}, where \code{m} is the number of different rates \code{m = length(cn)}.
#' }
#'
#' @import utils
#' @import foreach
#' @import doSNOW
#' @export
#'
#' @examples simuSamples(generateMeans(5,4,3), sqrt(c(50,100)), 50)
simuSamples = function(mu, cn, reps, nonneg = FALSE,
                       est.cov = TRUE, prl = FALSE){

  p = dim(mu)[1]
  d = dim(mu)[3]
  out.groups = dim(mu)[2]
  num.size = length(cn)

  if (nonneg) {
    markovProcess = function(P,L){
      L = floor(L)
      n = nrow(P)
      Label = matrix(0, nrow = L+1, ncol = 1)
      CountMat = matrix(0, nrow = n, ncol = n)
      Label[1] = sample(n,1)
      for (l in 2:(L+1)) {
        Label[l] = sample(n,1,prob = P[Label[l-1],],replace = TRUE)
        CountMat[Label[l-1], Label[l]] = CountMat[Label[l-1], Label[l]]+1
      }
      for (i in 1:n) {
        sums = 1/sum(CountMat[i,])
        if (is.infinite(sums)) {sums = 0}
        CountMat[i,] = CountMat[i,]*sums[1]
      }

      if (est.cov) {
        CovMat = matrix(0, ncol = n^2, nrow = n^2)
        pi = matrix(0, nrow = n, ncol = 1)
        for (i in 1:n) {
          pi[i] = sum(Label == i)/(L+1)
        }
        vec = 1/pi
        vec[is.infinite(vec)] = 0
        for (i in 1:n) {
          Ei = matrix(0, ncol = n, nrow = n)
          Ei[i,i] = 1
          Qi = diag(CountMat[i,]) - matrix(CountMat[i,], nrow = n, ncol = n) * matrix(CountMat[i,], nrow = n, ncol = n, byrow = T)
          CovMat = CovMat + kronecker(Qi * vec[i], Ei)
        }
        dim(CovMat) = c(rep(1, 4), dim(CovMat))
      }
      dim(CountMat) = c(rep(1, 4), dim(CountMat))
      if (est.cov) {return(list(CountMat, CovMat))}
      return(list(CountMat))
    }
  } else {
    estMat = function(Mat, n){
      n = floor(n)
      d = nrow(Mat)
      erMat = matrix(0, n, d^2)
      for (i in 1:n) {
        erMat[i,] = rnorm(d^2)
      }
      estMat = Mat + matrix(colMeans(erMat), nrow = d)
      if (est.cov) {CovMat = cov(erMat); dim(CovMat) = c(rep(1, 4), dim(CovMat))}
      dim(estMat) = c(rep(1, 4), dim(estMat))
      if (est.cov) {return(list(estMat, CovMat))}
      return(list(estMat))
    }
  }

  acomb1 = function(...) acomb(..., along = 1)
  acomb2 = function(...) acomb(..., along = 2)
  acomb3 = function(...) acomb(..., along = 3)
  acomb4 = function(...) acomb(..., along = 4)


  if (prl) {
    cat('Sampling: \n')
    pb <- txtProgressBar(max = num.size*out.groups*reps*p, style = 3)
    progress <- function(n) {setTxtProgressBar(pb, n)}
    opts <- list(progress = progress)

    output = foreach(cm = cn, .combine = acomb1,
                     .options.snow = opts) %:%
      foreach(l=1:out.groups, .combine = acomb2) %:%
      foreach(j=1:reps, .combine = acomb3) %:%
      foreach(i=1:p, .combine = acomb4) %dopar% {
        if (nonneg) { out = markovProcess(mu[i,l,,], cm^2) }
        else { out = estMat(mu[i,l,,], cm^2) }
        out
      }
  } else {
    output = foreach(cm = cn, .combine = acomb1) %:%
      foreach(l=1:out.groups, .combine = acomb2) %:%
      foreach(j=1:reps, .combine = acomb3) %:%
      foreach(i=1:p, .combine = acomb4) %do% {
        if (nonneg) { out = markovProcess(mu[i,l,,], cm^2) }
        else { out = estMat(mu[i,l,,], cm^2) }
        out
      }
  }
  names(output)[1] = 'mu.bar'
  dimnames(output[[1]]) = list(
    paste0('Sample size n=', round(cn^2)),
    dimnames(mu)[[2]],
    paste0('Replica #', 1:reps),
    dimnames(mu)[[1]],
    NULL, NULL
  )
  if (est.cov) {
    names(output)[2] = 'cov.bar'
    dimnames(output[[2]]) = list(
      paste0('Sample size n=', round(cn^2)),
      dimnames(mu)[[2]],
      paste0('Replica #', 1:reps),
      dimnames(mu)[[1]],
      NULL, NULL
    )
  }
  return(output)

  # for (s in 1:num.size) {
  #   cm = cn[s]
  #   for (l in 1:out.groups) {
  #     for (j in 1:reps) {
  #       for (i in 1:p) {
  #         if (nonneg) {
  #           TPM = markovProcess(mu[i,l,,], cm^2)
  #           if (is.list(TPM)) {
  #             out.samples[s,l,j,i,,] = TPM[[1]]
  #             out.cov[s,l,j,i,,] = TPM[[2]]
  #           } else {
  #             out.samples[s,l,j,i,,] = TPM
  #           }
  #         } else {
  #           estM = estMat(mu[i,l,,], cm^2)
  #           if (is.list(estM)) {
  #             out.samples[s,l,j,i,,] = estM[[1]]
  #             out.cov[s,l,j,i,,] = estM[[2]]
  #           }
  #           out.samples[s,l,j,i,,] = estM
  #         }
  #       }
  #     }
  #   }
  # }
  # if (est.cov) {return(list(mu.bar = out.samples, cov.bar = out.cov))}
  # else {return(list(mu.bar = out.samples))}
}
