#' Generating consistent estimators for given means
#'
#' The consistent estimators are obtained either as the mean of standard normally distributed matrices,
#' or as the estimated transition probability matrix of simulated Markov processes.
#' In addition the estimated covariance matrices are also returned.
#'
#' @param reps The number of replicates for the same distribution.
#' @param cn The vector of convergence rates in each replicate. Assume \code{n} is the sample size, usually CLT indicates \code{cn = sqrt(n)} for consistent estimators.
#' @param mu The array of mean matrices, possibly generated by function \code{generateMeans}. Dimension should be \code{p}-by-\code{q}-by-\code{d}-by-\code{d}, where \code{p} is the number of matrices, \code{q} is the number of SNR's to be used, and \code{d} is the dimension of square matrices.
#' @param nn Logical, whether the generated matrices should be nonnegative as transition probability matrices. Default to \code{nn = FALSE}
#' @param est.cov Logical, whether the covariance matrices are estimated empirically. Default to \code{est.cov = TRUE}.
#' @param prl Logical, whether to use parallel sampling. Default to \code{prl = FALSE} for not parallelizing. If \code{prl = TRUE}, one must first call \code{registerDoSNOW()} externally.
#'
#' @return A list of lists, with length \code{reps * m * q}, where \code{m} is the number of different rates \code{m = length(cn)}. Every sublist has the following format.
#' \itemize{
#' \item \code{SNR}: The string indicating the signal to noise ratio.
#' \item \code{CovRate}: The numerical value indicating the corresponding convergence rate in \code{cn}.
#' \item \code{mu.bar}: The array of consistent estimators of the mean matrices, with dimension \code{p}-\code{d}-by-\code{d}.
#' \item \code{cov.bar}: The array of consistent estimators of covariance matrices, with dimension \code{p}-\code{d^2}-by-\code{d^2}.
#' }
#' When \code{est.cov = FALSE}, only the first array of mean estimators are included in the sublist.
#'
#' @import utils
#' @import foreach
#' @import doSNOW
#' @import abind
#' @importFrom 'Rdpack' reprompt
#' @export
#'
#' @references
#'     \insertRef{xu2021testing}{eigTest}.
#'
#' @examples simuSamples(generateMeans(5,4,3), sqrt(c(50,100)), 50)
simuSamples = function(mu, cn, reps, nn = FALSE,
                       est.cov = TRUE, prl = FALSE){

  p = dim(mu)[1]; matIDs = dimnames(mu)[[1]]
  out.groups = dim(mu)[2]; snrs = dimnames(mu)[[2]]
  d = dim(mu)[3]
  num.size = length(cn)

  if (nn) {
    estMat = function(Mat, cm, s, i){
      n = round(cm^2)
      d = nrow(Mat)
      Label = matrix(0, nrow = n+1, ncol = 1)
      CountMat = matrix(0, nrow = d, ncol = d)
      Label[1] = sample(d,1)
      for (l in 2:(n+1)) {
        Label[l] = sample(d,1,prob = Mat[,Label[l-1]],replace = TRUE)
        CountMat[Label[l-1], Label[l]] = CountMat[Label[l-1], Label[l]]+1
      }
      sums = 1 / rowSums(CountMat)
      sums[is.infinite(sums)] = 0
      CountMat = CountMat * sums

      if (est.cov) {
        CovMat = matrix(0, ncol = d^2, nrow = d^2)
        pi = matrix(0, nrow = d, ncol = 1)
        for (j in 1:d) {
          pi[j] = sum(Label == j)/(n+1)
        }
        vec = 1/pi
        vec[is.infinite(vec)] = 0
        Ei = matrix(0, ncol = d, nrow = d)
        for (j in 1:d) {
          Ei[j,j] = 1
          Qi = diag(CountMat[j,]) - matrix(CountMat[j,], nrow = d, ncol = d) * matrix(CountMat[j,], nrow = d, ncol = d, byrow = T)
          CovMat = CovMat + kronecker(Qi * vec[j], Ei)
          Ei[j,j] = 0
        }
        CovMat = CovMat[as.vector(matrix(1:d^2, ncol = d, byrow = T)),
                        as.vector(matrix(1:d^2, ncol = d, byrow = T))]
        dim(CovMat) = c(1, dim(CovMat))
      }
      CountMat = t(CountMat)
      dim(CountMat) = c(1, dim(CountMat))
      dimnames(CountMat) = list(matIDs[i], NULL, NULL)
      if (est.cov) {
        dimnames(CovMat) = dimnames(CountMat)
        return(list(SNR = snrs[s], CovRate = cm, mu.bar = CountMat, cov.bar = CovMat))
      }
      return(list(SNR = snrs[s], CovRate = cm, mu.bar = CountMat))
    }
  } else {
    estMat = function(Mat, cm, s, i){
      n = round(cm^2)
      d = nrow(Mat)
      erMat = matrix(0, n, d^2)
      for (j in 1:n) {
        erMat[j,] = rnorm(d^2)
      }
      estMat = Mat + matrix(colMeans(erMat), nrow = d)
      if (est.cov) {CovMat = cov(erMat); dim(CovMat) = c(1, dim(CovMat))}
      dim(estMat) = c(1, dim(estMat))
      dimnames(estMat) = list(matIDs[i], NULL, NULL)
      if (est.cov) {
        dimnames(CovMat) = dimnames(estMat)
        return(list(SNR = snrs[s], CovRate = cm, mu.bar = estMat, cov.bar = CovMat))
      }
      return(list(SNR = snrs[s], CovRate = cm, mu.bar = estMat))
    }
  }

  acomb = function(...){
    argl = list(...)
    out = argl[[1]]
    if (length(argl) >= 2) {
      for (i in 2:length(argl)) {
        out$mu.bar = abind(out$mu.bar, argl[[i]]$mu.bar, along = 1)
        if (length(out) == 4) {out$cov.bar = abind(out$cov.bar, argl[[i]]$cov.bar, along = 1)}
      }
    }
    return(out)
  }

  cm = NULL; i = NULL; s = NULL; j = NULL
  if (prl) {
    cat('Sampling: \n')
    pb <- txtProgressBar(max = num.size*out.groups*reps*p, style = 3)
    progress <- function(n) {setTxtProgressBar(pb, n)}
    opts <- list(progress = progress)

    output = foreach(j=1:reps, .options.snow = opts, .combine = c,
                     .multicombine = T, .inorder = F) %:%
      foreach(cm = cn, .combine = c, .inorder = F) %:%
      foreach(s = 1:out.groups, .inorder = F) %:%
      foreach(i = 1:p, .combine = acomb) %dopar% {
        if (j %% max(50, reps %/% 5) == 1 && s == 1 && i == 1 && cm == cn[1]) {gc()}
        return(estMat(mu[i,s,,], cm, s, i))
      }
  } else {
    output = foreach(j=1:reps, .combine = c, .multicombine = T, .inorder = F) %:%
      foreach(cm = cn, .combine = c, .inorder = F) %:%
      foreach(s = 1:out.groups, .inorder = F) %:%
      foreach(i = 1:p, .combine = acomb) %do% {
        if (j %% max(5, reps %/% 10) == 1 && s == 1 && i == 1 && cm == cn[1]) {gc()}
        return(estMat(mu[i,s,,], cm, s, i))
      }
  }
  gc()
  return(output)
}
